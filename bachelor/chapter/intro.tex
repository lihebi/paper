
\chapter{绪论}

即时多人聊天应用，例如qq，msn等热门应用，
所提供的关键功能是让群体中的每一个人都能向群体中发送消息，接受消息。
不同于两人聊天，多人聊天就涉及到如何让所有人都能收到其他人所发送的消息。
现阶段，此类应用都是运行在现有网络，即IP网络上的。这为其带来了不可避免的弊端。

IP网络被设计成点对点的通信，即通信过程中，整个网络层所知道的是通信源点和目标节点的IP地址。
路由器根据IP地址解析出下一跳的路径，并传递数据包。

在IP网络上，这些应用的同步算法是要有中央服务器的。每个人都和中央服务器建立连接。
中央服务器负责收集每个人的发送的消息，并将这些消息转发给其余所有人。
当一个参与者发送了一条文本信息，此信息会先经过路由到达中央服务器。
中央服务器维护了一个包含所有参与者的列表，
它收到消息后，经过计算处理，然后将此消息转发给需要它的人，以完成功能。

虽然这种办法可行，而且实际上在IP网络上也只能这样运行。
但是这种方法带来了严重的性能问题。

\begin{enumerate}
\item 存在大量的overhead

由于IP是点对点通信，这意味着中央服务器想要将一个消息传递给一个聊天室里的所有成员时，
不得不建立与所有人的TCP连接，并向每一个连接发送一份消息的副本。
如果有两个聊天用户在拓扑上非常近（例如他们连在同一个路由器上，而服务器可能在十跳之外。
这种情况下，需要两个相同的数据包，在这十个路由器上经过，而事实上只需要一个。
在群聊的环境中，用户量更大，更密集，从而造成更加大得多的overhead。
\item 鲁棒性不强

由于所有通信的实现都需要中央服务器的调节，这造成了单点故障。
如果服务器宕机了，或者被不法分子攻击，整个网络中的所有成员均不能正常通讯。
系统也无法自我修复，必须等到服务器维修好后才能重新上线服务。
\end{enumerate}


IP的点对点的通讯模型导致了这些性能瓶颈，
而Named Data Network作为最近发展的一个新的网络架构，为解决这个问题提供了机会。
NDN的优于IP网络模型的根本点在于它不是点对点的模型。
NDN中，所有的资源使用一个独一无二的名字来索引，每个名字对应了一个资源。
资源获取是消费者主导的，也就是说，客户端想要访问一个资源时，
他以此资源的名字发送Interest数据包，并等待接受返回的数据。
由于资源是以名字来定义的，所有请求同一个资源的用户所发送的请求都是一样的：资源的独一无二的名字，
那么NDN中的路由器就会检测到相同的兴趣包，而不会将这个重复的兴趣包向下一跳传递。
当有内容返回时，NDN路由会将这个数据包向所有的端口转发，从而实现多路转发。
除此之外，NDN路由还涉及了缓存机制，当有内容数据包返回时，它会将这个包缓存在自己的内存中。
如果之后有用户请求相同的资源，NDN路由就会发现这个资源已经在自己的缓存中了，于是便可以直接返回给客户端。
这显著的减少了overhead，而且加快了数据包响应时间。

基于NDN的这些特性，它可以为即时多人聊天应用提供很好的架构基础，为解决这个性能瓶颈提供了新的机会。
利用这些特性，以上的问题可以得到较好的解决。
由于NDN的资源是有独特名字的，聊天室里的每一个人想要得到最新消息时，发送的兴趣包是相同的。
NDN路由会过滤掉所有重复的兴趣包，而往下一个路由只发送一份。
当数据返回时，内容包也会只有一份传递回来，并且由路由向各个端口分发数据包。
这样就实现了比传统IP方式小得多的overhead。
另一个方面，由于NDN不关心端点的IP，所有流量都是由Interest包的名字决定的，
因此可以将算法设计成分布式的，当有些节点出现故障，系统仍然可以继续工作，并且可以自我修复。

最近NDN研究人员提出了一种基于此的解决方案，ChronoSync。
这个方案是一个完全的分布式的算法，每一个用户都要定期向整个系统广播一个代表他自己当前状态的Interest。
任何人都可以回复这条Interest，只要他认识这个状态，而且他自己的状态更新。
在系统稳定时，每个人都会保留着其他人的Interest，
一旦自己有消息要发送，便立即响应这些Interest，从而将消息发布给团体里的所有人。

ChronoSync为此问题提供了很好的尝试和解决方案，也证明了比IP为基础的算法有明显的优势。
然而，这个算法仍有严重的不足。最大的问题在于，它是一个完全分布的算法，系统没有能力处理特殊情况。
例如，当有两个成员同时发布消息，他们都会响应所保留的别人发来的Interest。
然而，在NDN中，一个Interest只能带回一个数据包，这就必然导致有一个人的消息无法到达。
这样，系统就被分为两个不同阵营，各自有着不同的消息状态，互相无法识别。
更加糟糕的是，当系统里有很多人，出现这种情况的几率将会非常普遍，系统甚至会被分成若干个不同的阵营。
另外，ChronoSync的设计就决定了它无法扩展。每个人需要向全网广播兴趣包，来获取新的消息。
这样这个系统就只能在有限的小范围内使用，如果想在大范围内使用，就必须有分层机制，让复杂度指数递减。

在这种情况下，我们提出了TreeSync来解决此问题。我们的设计目标有以下几点：

\begin{enumerate}
  \item 必须是分布式的。这样才能是系统更健壮，鲁棒性更强。
  \item 有能力处理特殊情况，包括多个并发的消息。
  \item 要能在大范围内进行扩展。
\end{enumerate}

我主要完成的工作有：

\begin{enumerate}
  \item 设计了TreeSync来解决NDN中即时多人聊天应用的信息同步问题。
  \item 在ndnSIM中做了仿真。
  \item 与ChronoSync做对比，证明算法的优越性。
\end{enumerate}

接下来各章将会按照如下方式展开。在第二章，将会介绍NDN相关背景和其特性，为后文的算法描述做基础。
第三章，将会详细讨论算法的设计细节。第四章讨论现有的工作。第五章总结全文。
